import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import json
import os
import hashlib
from datetime import datetime, timedelta
import numpy as np

# Page configuration
st.set_page_config(
    page_title="KAITO Market Dashboard",
    page_icon="üìà",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Import authentication configuration
import sys
import os
sys.path.append(os.path.dirname(os.path.abspath(__file__)))
from auth_config import ADMIN_PASSWORD 

# Custom CSS
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        font-weight: bold;
        text-align: center;
        color: #1f77b4;
        margin-bottom: 2rem;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
    }
    .spike-alert {
        background-color: #fff3cd;
        border-left: 4px solid #ffc107;
        padding: 1rem;
        margin: 1rem 0;
    }
    .stMetric {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
    }
</style>
""", unsafe_allow_html=True)

# Load data function
@st.cache_data
def load_data():
    """Load all data files generated by the backend"""
    data = {}
    
    # Load market data
    market_data_path = './data/kaito_market_data.csv'
    if os.path.exists(market_data_path):
        data['market'] = pd.read_csv(market_data_path)
        data['market']['timestamp'] = pd.to_datetime(data['market']['timestamp'])
        data['market']['date'] = pd.to_datetime(data['market']['date'])
    else:
        st.error(f"Market data not found at {market_data_path}. Please run the backend analysis first.")
        return None
    
    # Load spike data
    spike_data_path = './data/kaito_spikes.csv'
    if os.path.exists(spike_data_path):
        data['spikes'] = pd.read_csv(spike_data_path)
        if not data['spikes'].empty:
            data['spikes']['timestamp'] = pd.to_datetime(data['spikes']['timestamp'])
            data['spikes']['date'] = pd.to_datetime(data['spikes']['date'])
    else:
        data['spikes'] = pd.DataFrame()
    
    # Load JSON report
    report_path = './reports/kaito_analysis.json'
    if os.path.exists(report_path):
        with open(report_path, 'r') as f:
            data['report'] = json.load(f)
    else:
        st.warning("Analysis report not found. Some statistics may be unavailable.")
        data['report'] = {}
    
    return data

# Create price chart with volume
def create_price_volume_chart(df, spikes_df):
    """Create interactive price and volume chart"""
    fig = make_subplots(
        rows=2, cols=1,
        shared_xaxes=True,
        vertical_spacing=0.05,
        row_heights=[0.7, 0.3],
        subplot_titles=('Price Movement', 'Trading Volume')
    )
    
    # Price line
    fig.add_trace(
        go.Scatter(
            x=df['timestamp'],
            y=df['price'],
            mode='lines',
            name='Price',
            line=dict(color='#1f77b4', width=2),
            hovertemplate='Date: %{x}<br>Price: $%{y:.4f}<extra></extra>'
        ),
        row=1, col=1
    )
    
    # Moving average
    if 'price_ma7' in df.columns:
        fig.add_trace(
            go.Scatter(
                x=df['timestamp'],
                y=df['price_ma7'],
                mode='lines',
                name='7-day MA',
                line=dict(color='orange', width=1, dash='dash'),
                hovertemplate='Date: %{x}<br>7-day MA: $%{y:.4f}<extra></extra>'
            ),
            row=1, col=1
        )
    
    # Add price spikes
    if not spikes_df.empty:
        price_spikes = spikes_df[spikes_df['metric'] == 'price']
        
        # Up spikes
        up_spikes = price_spikes[price_spikes['direction'] == 'up']
        if not up_spikes.empty:
            fig.add_trace(
                go.Scatter(
                    x=up_spikes['timestamp'],
                    y=up_spikes['value'],
                    mode='markers',
                    name='Price Spike Up',
                    marker=dict(color='green', size=12, symbol='triangle-up'),
                    hovertemplate='Date: %{x}<br>Price: $%{y:.4f}<br>Change: +%{text}<extra></extra>',
                    text=[f"{x:.1f}%" for x in up_spikes['change_pct']]
                ),
                row=1, col=1
            )
        
        # Down spikes
        down_spikes = price_spikes[price_spikes['direction'] == 'down']
        if not down_spikes.empty:
            fig.add_trace(
                go.Scatter(
                    x=down_spikes['timestamp'],
                    y=down_spikes['value'],
                    mode='markers',
                    name='Price Spike Down',
                    marker=dict(color='red', size=12, symbol='triangle-down'),
                    hovertemplate='Date: %{x}<br>Price: $%{y:.4f}<br>Change: %{text}<extra></extra>',
                    text=[f"{x:.1f}%" for x in down_spikes['change_pct']]
                ),
                row=1, col=1
            )
    
    # Volume bars
    colors = ['green' if df['volume'].iloc[i] > df['volume'].iloc[i-1] else 'red' 
              for i in range(1, len(df))]
    colors = ['gray'] + colors
    
    fig.add_trace(
        go.Bar(
            x=df['timestamp'],
            y=df['volume'],
            name='Volume',
            marker_color=colors,
            opacity=0.7,
            hovertemplate='Date: %{x}<br>Volume: $%{y:,.0f}<extra></extra>'
        ),
        row=2, col=1
    )
    
    # Update layout
    fig.update_xaxes(title_text="Date", row=2, col=1)
    fig.update_yaxes(title_text="Price (USD)", row=1, col=1)
    fig.update_yaxes(title_text="Volume (USD)", row=2, col=1)
    
    fig.update_layout(
        height=700,
        showlegend=True,
        hovermode='x unified',
        template='plotly_white'
    )
    
    return fig

# Create volatility chart
def create_volatility_chart(df):
    """Create volatility analysis chart"""
    # Calculate rolling volatility
    df['returns'] = df['price'].pct_change()
    df['volatility_7d'] = df['returns'].rolling(window=7).std() * np.sqrt(7) * 100
    df['volatility_14d'] = df['returns'].rolling(window=14).std() * np.sqrt(14) * 100
    
    fig = go.Figure()
    
    fig.add_trace(
        go.Scatter(
            x=df['timestamp'],
            y=df['volatility_7d'],
            mode='lines',
            name='7-day Volatility',
            line=dict(color='blue', width=2),
            hovertemplate='Date: %{x}<br>7-day Vol: %{y:.2f}%<extra></extra>'
        )
    )
    
    fig.add_trace(
        go.Scatter(
            x=df['timestamp'],
            y=df['volatility_14d'],
            mode='lines',
            name='14-day Volatility',
            line=dict(color='red', width=2),
            hovertemplate='Date: %{x}<br>14-day Vol: %{y:.2f}%<extra></extra>'
        )
    )
    
    fig.update_layout(
        title='Price Volatility Analysis',
        xaxis_title='Date',
        yaxis_title='Volatility (%)',
        height=400,
        template='plotly_white',
        hovermode='x unified'
    )
    
    return fig

# Create distribution charts
def create_distribution_charts(df):
    """Create price and volume distribution charts"""
    fig = make_subplots(
        rows=1, cols=2,
        subplot_titles=('Daily Price Changes Distribution', 'Daily Volume Distribution')
    )
    
    # Price changes histogram
    fig.add_trace(
        go.Histogram(
            x=df['price_change_pct'].dropna(),
            nbinsx=20,
            name='Price Changes',
            marker_color='lightblue',
            showlegend=False
        ),
        row=1, col=1
    )
    
    # Volume histogram
    fig.add_trace(
        go.Histogram(
            x=df['volume'] / 1e6,  # Convert to millions
            nbinsx=20,
            name='Volume',
            marker_color='lightgreen',
            showlegend=False
        ),
        row=1, col=2
    )
    
    fig.update_xaxes(title_text="Daily Change (%)", row=1, col=1)
    fig.update_xaxes(title_text="Volume (Million USD)", row=1, col=2)
    fig.update_yaxes(title_text="Frequency", row=1, col=1)
    fig.update_yaxes(title_text="Frequency", row=1, col=2)
    
    fig.update_layout(
        height=400,
        template='plotly_white'
    )
    
    return fig

# Create correlation heatmap
def create_correlation_matrix(df):
    """Create correlation matrix heatmap"""
    # Select numerical columns
    corr_columns = ['price', 'volume', 'price_change_pct', 'volume_change_pct']
    corr_data = df[corr_columns].corr()
    
    fig = go.Figure(data=go.Heatmap(
        z=corr_data,
        x=corr_data.columns,
        y=corr_data.columns,
        colorscale='RdBu',
        zmid=0,
        text=corr_data.round(3),
        texttemplate='%{text}',
        textfont={"size": 12},
        hoverongaps=False
    ))
    
    fig.update_layout(
        title='Correlation Matrix',
        height=400,
        template='plotly_white'
    )
    
    return fig

# Main app
def main():
    # Password protection
    if "authenticated" not in st.session_state:
        st.session_state.authenticated = False
        
    if not st.session_state.authenticated:
        st.markdown('<h1 class="main-header">üöÄ KAITO Market Activity Dashboard</h1>', unsafe_allow_html=True)
        st.markdown("### üîí Authentication Required")
        password = st.text_input("Enter dashboard password:", type="password")
        
        if st.button("Login"):
            if password == ADMIN_PASSWORD:
                st.session_state.authenticated = True
                st.experimental_rerun()
            else:
                st.error("‚ùå Incorrect password! Please try again.")
        
        # Show some minimal information to unauthenticated users
        st.markdown("---")
        st.info("This dashboard contains market analysis data for KAITO token. Please enter the correct password to access the dashboard.")
        st.stop()
    
    # Header - only shown to authenticated users
    st.markdown('<h1 class="main-header">üöÄ KAITO Market Activity Dashboard</h1>', unsafe_allow_html=True)
    
    # Add logout button in sidebar
    with st.sidebar:
        if st.button("üö™ Logout"):
            st.session_state.authenticated = False
            st.experimental_rerun()
    
    # Load data
    with st.spinner('Loading data...'):
        data = load_data()
    
    if data is None:
        st.stop()
    
    df = data['market']
    spikes_df = data['spikes']
    report = data['report']
    
    # Sidebar
    with st.sidebar:
        st.header("üìä Dashboard Controls")
        
        # Date range filter
        st.subheader("Date Range")
        date_range = st.date_input(
            "Select date range",
            value=(df['date'].min(), df['date'].max()),
            min_value=df['date'].min(),
            max_value=df['date'].max()
        )
        
        if len(date_range) == 2:
            mask = (df['date'] >= pd.Timestamp(date_range[0])) & (df['date'] <= pd.Timestamp(date_range[1]))
            df_filtered = df[mask]
        else:
            df_filtered = df
        
        # View selector
        st.subheader("View Options")
        view_mode = st.radio(
            "Select View",
            ["Overview", "Price Analysis", "Volume Analysis", "Spike Detection", "Statistics"]
        )
        
        # Refresh button
        if st.button("üîÑ Refresh Data", use_container_width=True):
            st.cache_data.clear()
            st.rerun()
    
    # Main content based on view mode
    if view_mode == "Overview":
        # Key metrics row
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            current_price = df_filtered['price'].iloc[-1]
            price_change = report.get('statistics', {}).get('price', {}).get('change_30d', 0)
            st.metric(
                "Current Price",
                f"${current_price:.4f}",
                f"{price_change:+.2f}%"
            )
        
        with col2:
            total_volume = df_filtered['volume'].sum()
            st.metric(
                "Total Volume",
                f"${total_volume/1e9:.2f}B",
                "30-day period"
            )
        
        with col3:
            volatility = report.get('statistics', {}).get('price', {}).get('volatility', 0)
            st.metric(
                "Volatility",
                f"{volatility:.2f}%",
                "Price volatility"
            )
        
        with col4:
            spike_count = len(spikes_df) if not spikes_df.empty else 0
            st.metric(
                "Spike Events",
                spike_count,
                "Detected spikes"
            )
        
        # Main chart
        st.subheader("üìà Price & Volume Overview")
        fig_main = create_price_volume_chart(df_filtered, spikes_df)
        st.plotly_chart(fig_main, use_container_width=True)
        
        # Additional charts row
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("üìä Volatility Trend")
            fig_vol = create_volatility_chart(df_filtered)
            st.plotly_chart(fig_vol, use_container_width=True)
        
        with col2:
            st.subheader("üîó Correlations")
            fig_corr = create_correlation_matrix(df_filtered)
            st.plotly_chart(fig_corr, use_container_width=True)
    
    elif view_mode == "Price Analysis":
        st.header("üí∞ Price Analysis")
        
        # Price statistics
        col1, col2, col3, col4 = st.columns(4)
        
        price_stats = report.get('statistics', {}).get('price', {})
        
        with col1:
            st.metric("High", f"${price_stats.get('high', 0):.4f}")
        with col2:
            st.metric("Low", f"${price_stats.get('low', 0):.4f}")
        with col3:
            st.metric("Average", f"${price_stats.get('average', 0):.4f}")
        with col4:
            st.metric("Std Dev", f"${price_stats.get('std_dev', 0):.4f}")
        
        # Price chart with indicators
        fig_price = go.Figure()
        
        # Price line
        fig_price.add_trace(
            go.Scatter(
                x=df_filtered['timestamp'],
                y=df_filtered['price'],
                mode='lines',
                name='Price',
                line=dict(color='blue', width=2)
            )
        )
        
        # Bollinger Bands
        df_filtered['bb_middle'] = df_filtered['price'].rolling(window=20).mean()
        df_filtered['bb_std'] = df_filtered['price'].rolling(window=20).std()
        df_filtered['bb_upper'] = df_filtered['bb_middle'] + (2 * df_filtered['bb_std'])
        df_filtered['bb_lower'] = df_filtered['bb_middle'] - (2 * df_filtered['bb_std'])
        
        fig_price.add_trace(
            go.Scatter(
                x=df_filtered['timestamp'],
                y=df_filtered['bb_upper'],
                mode='lines',
                name='Upper Band',
                line=dict(color='gray', width=1, dash='dash')
            )
        )
        
        fig_price.add_trace(
            go.Scatter(
                x=df_filtered['timestamp'],
                y=df_filtered['bb_lower'],
                mode='lines',
                name='Lower Band',
                line=dict(color='gray', width=1, dash='dash'),
                fill='tonexty',
                fillcolor='rgba(128, 128, 128, 0.2)'
            )
        )
        
        fig_price.update_layout(
            title='Price with Bollinger Bands',
            xaxis_title='Date',
            yaxis_title='Price (USD)',
            height=500,
            template='plotly_white',
            hovermode='x unified'
        )
        
        st.plotly_chart(fig_price, use_container_width=True)
        
        # Price change distribution
        st.subheader("üìä Price Change Distribution")
        fig_dist = px.histogram(
            df_filtered['price_change_pct'].dropna(),
            nbins=30,
            title='Daily Price Change Distribution',
            labels={'value': 'Price Change (%)', 'count': 'Frequency'}
        )
        st.plotly_chart(fig_dist, use_container_width=True)
    
    elif view_mode == "Volume Analysis":
        st.header("üìä Volume Analysis")
        
        # Volume statistics
        col1, col2, col3, col4 = st.columns(4)
        
        volume_stats = report.get('statistics', {}).get('volume', {})
        
        with col1:
            st.metric("Total Volume", f"${volume_stats.get('total_30d', 0)/1e9:.2f}B")
        with col2:
            st.metric("Daily Average", f"${volume_stats.get('average_daily', 0)/1e6:.2f}M")
        with col3:
            st.metric("Highest Day", f"${volume_stats.get('highest', 0)/1e6:.2f}M")
        with col4:
            st.metric("Lowest Day", f"${volume_stats.get('lowest', 0)/1e6:.2f}M")
        
        # Volume chart
        fig_volume = go.Figure()
        
        # Volume bars with color coding
        colors = ['green' if df_filtered['volume'].iloc[i] > df_filtered['volume'].iloc[i-1] else 'red' 
                  for i in range(1, len(df_filtered))]
        colors = ['gray'] + colors
        
        fig_volume.add_trace(
            go.Bar(
                x=df_filtered['timestamp'],
                y=df_filtered['volume'],
                marker_color=colors,
                name='Volume',
                hovertemplate='Date: %{x}<br>Volume: $%{y:,.0f}<extra></extra>'
            )
        )
        
        # Add moving average
        if 'volume_ma7' in df_filtered.columns:
            fig_volume.add_trace(
                go.Scatter(
                    x=df_filtered['timestamp'],
                    y=df_filtered['volume_ma7'],
                    mode='lines',
                    name='7-day MA',
                    line=dict(color='orange', width=2)
                )
            )
        
        fig_volume.update_layout(
            title='Trading Volume Analysis',
            xaxis_title='Date',
            yaxis_title='Volume (USD)',
            height=500,
            template='plotly_white',
            hovermode='x unified'
        )
        
        st.plotly_chart(fig_volume, use_container_width=True)
        
        # Volume vs Price scatter
        st.subheader("üîÑ Volume vs Price Relationship")
        fig_scatter = px.scatter(
            df_filtered,
            x='volume',
            y='price',
            color='price_change_pct',
            color_continuous_scale='RdYlGn',
            title='Volume vs Price Correlation',
            labels={'volume': 'Volume (USD)', 'price': 'Price (USD)', 'price_change_pct': 'Price Change %'}
        )
        st.plotly_chart(fig_scatter, use_container_width=True)
    
    elif view_mode == "Spike Detection":
        st.header("üéØ Spike Detection Analysis")
        
        if spikes_df.empty:
            st.info("No significant spikes detected in the selected period.")
        else:
            # Spike summary
            col1, col2, col3 = st.columns(3)
            
            with col1:
                price_spikes = len(spikes_df[spikes_df['metric'] == 'price'])
                st.metric("Price Spikes", price_spikes)
            
            with col2:
                volume_spikes = len(spikes_df[spikes_df['metric'] == 'volume'])
                st.metric("Volume Spikes", volume_spikes)
            
            with col3:
                max_spike = spikes_df['change_pct'].max()
                st.metric("Largest Spike", f"{max_spike:.1f}%")
            
            # Spike timeline
            st.subheader("üìÖ Spike Timeline")
            
            fig_timeline = go.Figure()
            
            # Add price line as background
            fig_timeline.add_trace(
                go.Scatter(
                    x=df_filtered['timestamp'],
                    y=df_filtered['price'],
                    mode='lines',
                    name='Price',
                    line=dict(color='lightgray', width=1),
                    showlegend=False
                )
            )
            
            # Add spike markers
            for _, spike in spikes_df.iterrows():
                color = 'green' if spike['direction'] == 'up' else 'red'
                symbol = 'triangle-up' if spike['direction'] == 'up' else 'triangle-down'
                
                fig_timeline.add_trace(
                    go.Scatter(
                        x=[spike['timestamp']],
                        y=[spike.get('price', spike.get('value', 0))],
                        mode='markers+text',
                        marker=dict(color=color, size=15, symbol=symbol),
                        text=[f"{spike['change_pct']:.1f}%"],
                        textposition='top center',
                        name=f"{spike['type']} spike",
                        showlegend=False
                    )
                )
            
            fig_timeline.update_layout(
                title='Spike Events on Price Timeline',
                xaxis_title='Date',
                yaxis_title='Price (USD)',
                height=500,
                template='plotly_white'
            )
            
            st.plotly_chart(fig_timeline, use_container_width=True)
            
            # Spike details table
            st.subheader("üìã Spike Details")
            
            spike_display = spikes_df.copy()
            spike_display['timestamp'] = spike_display['timestamp'].dt.strftime('%Y-%m-%d %H:%M')
            spike_display['change_pct'] = spike_display['change_pct'].round(2)
            spike_display['value'] = spike_display['value'].round(4)
            
            st.dataframe(
                spike_display[['timestamp', 'type', 'direction', 'change_pct', 'value']],
                use_container_width=True
            )
    
    elif view_mode == "Statistics":
        st.header("üìä Detailed Statistics")
        
        # Create tabs for different statistics
        tab1, tab2, tab3 = st.tabs(["Price Stats", "Volume Stats", "Market Stats"])
        
        with tab1:
            st.subheader("Price Statistics")
            
            price_stats = report.get('statistics', {}).get('price', {})
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("**Basic Statistics**")
                st.write(f"Current Price: ${price_stats.get('current', 0):.4f}")
                st.write(f"30-Day High: ${price_stats.get('high', 0):.4f}")
                st.write(f"30-Day Low: ${price_stats.get('low', 0):.4f}")
                st.write(f"Average Price: ${price_stats.get('average', 0):.4f}")
                st.write(f"Median Price: ${price_stats.get('median', 0):.4f}")
            
            with col2:
                st.markdown("**Change Metrics**")
                st.write(f"30-Day Change: {price_stats.get('change_30d', 0):.2f}%")
                st.write(f"30-Day Change (USD): ${price_stats.get('change_30d_usd', 0):.4f}")
                st.write(f"Standard Deviation: ${price_stats.get('std_dev', 0):.4f}")
                st.write(f"Volatility: {price_stats.get('volatility', 0):.2f}%")
        
        with tab2:
            st.subheader("Volume Statistics")
            
            volume_stats = report.get('statistics', {}).get('volume', {})
            
            col1, col2 = st.columns(2)
            
            with col1:
                st.markdown("**Volume Metrics**")
                st.write(f"Total Volume (30d): ${volume_stats.get('total_30d', 0):,.0f}")
                st.write(f"Average Daily: ${volume_stats.get('average_daily', 0):,.0f}")
                st.write(f"Median Daily: ${volume_stats.get('median_daily', 0):,.0f}")
            
            with col2:
                st.markdown("**Extremes**")
                st.write(f"Highest Volume: ${volume_stats.get('highest', 0):,.0f}")
                st.write(f"Lowest Volume: ${volume_stats.get('lowest', 0):,.0f}")
                st.write(f"Highest Volume Date: {volume_stats.get('highest_date', 'N/A')}")
        
        with tab3:
            st.subheader("Current Market Data")
            
            market_data = report.get('statistics', {}).get('current_market', {})
            
            if market_data:
                col1, col2 = st.columns(2)
                
                with col1:
                    st.markdown("**Market Metrics**")
                    st.write(f"Market Cap: ${market_data.get('market_cap', 0):,.0f}")
                    st.write(f"FDV: ${market_data.get('fully_diluted_valuation', 0):,.0f}")
                    st.write(f"Circulating Supply: {market_data.get('circulating_supply', 0):,.0f}")
                
                with col2:
                    st.markdown("**Price Changes**")
                    st.write(f"24h Change: {market_data.get('24h_change', 0):.2f}%")
                    st.write(f"7d Change: {market_data.get('7d_change', 0):.2f}%")
                    st.write(f"30d Change: {market_data.get('30d_change', 0):.2f}%")
            else:
                st.info("Current market data not available in the report.")
    
    # Footer
    st.markdown("---")
    st.markdown(
        """
        <div style='text-align: center; color: gray;'>
            <p>KAITO Market Activity Dashboard | Data provided by CoinGecko API</p>
            <p>Last updated: {}</p>
        </div>
        """.format(datetime.now().strftime("%Y-%m-%d %H:%M:%S")),
        unsafe_allow_html=True
    )

if __name__ == "__main__":
    main()